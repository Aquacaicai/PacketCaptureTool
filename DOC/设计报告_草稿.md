# 《网络抓包工具的设计与实现》课程设计报告（草稿）

## 1. 系统与分工完成情况
### 1.1 完成度概述
本项目已实现实时抓包、分层协议解析、可视化统计、资源占用监测以及 JSON 格式的捕获数据持久化，具备提交所需的主要功能模块。界面通过 CustomTkinter 构建，支持 BPF 过滤器输入、抓包控制、数据保存/加载以及三大信息页签（数据包详情、统计信息、资源监控），系统已能够闭环完成“抓取 → 解析 → 展示 → 保存/回放”的流程。

### 1.2 团队分工（待补充）
- TODO：组长姓名（负责整体设计与核心编码，占比 %）。
- TODO：组员A（负责 GUI 设计与统计图表，占比 %）。
- TODO：组员B（负责抓包/解析模块，占比 %）。
- TODO：组员C（负责资源监控与测试，占比 %）。

## 2. 系统所使用的开源接口
| 接口/库 | 用途 | 系统中承担的角色 |
| --- | --- | --- |
| Scapy AsyncSniffer | 提供底层数据包嗅探能力，支持 BPF 过滤与接口配置 | `CaptureManager` 封装其启动/停止过程，将捕获的原始包投递给 GUI 队列 |
| CustomTkinter/Tkinter | 构建现代化 GUI 控件 | `PacketCaptureApp` 的主界面、Treeview 列表、标签页、按钮、输入框等均依赖该库 |
| Matplotlib | 绘制 IPv6 占比折线图与 TCP/UDP/ARP 柱状图 | 在统计页嵌入 FigureCanvas，实现长时间窗口的可视化趋势分析 |
| psutil | 读取进程 CPU 与内存占用 | `ResourceMonitor` 线程按固定间隔产生资源采样，用于资源监控页及日志导出 |
| Python 标准库（queue、threading、dataclasses、json 等） | 实现跨线程通信、数据结构定义与持久化 | 保证抓包线程、解析逻辑与 GUI 的解耦；`storage.py` 使用 `json` 读写捕获文件 |

## 3. 系统的主要功能
1. **实时抓包**：支持 BPF 过滤表达式，按钮控制开始/停止抓包，最大显示条数可配置以防 UI 堵塞。
2. **协议解析**：解析 Ethernet、IPv4/IPv6、ARP、TCP/UDP/ICMP 以及 DNS 字段，按“概览-网络层-传输层-DNS”层级树展示。
3. **过滤与数据管理**：在顶部输入框录入过滤规则；支持抓包结果的 JSON 保存与加载，加载时可回放历史数据并刷新统计。
4. **统计与可视化**：维护协议计数表；绘制 24 小时 IPv6 占比折线图与 TCP/UDP/ARP 柱状比较条形图，满足课程对“至少一天时间跨度”的要求。
5. **资源监控**：显示程序开始时间、累计运行时长；定期采集 CPU/内存使用情况，支持导出资源日志用于长时间运行分析。

## 4. 系统的设计
### 4.1 结构图文字描述（供绘制）
用户交互界面 → 抓包控制器（CaptureManager） → 数据包解析模块（parse_packet） → 数据分发（队列） → 统计模块（TrafficStats）与资源监控（ResourceMonitor） → 数据展示/持久化（Treeview + Matplotlib + JSON 存储）。

### 4.2 整体架构说明
系统采用前后端同体的桌面应用架构。前端 GUI 负责采集用户输入、展示实时数据；后端由抓包线程、解析逻辑、统计计算与资源监控线程组成，通过线程安全的 `queue.Queue` 进行数据传递。持久化层以 JSON 文件形式保存解析后的结构化数据，便于离线加载与重复分析。

### 4.3 模块划分
- **界面层 (`app.py`)**：包含过滤器输入、控制按钮、数据包列表、详情树、统计页、资源监控页及保存/加载/导出操作。
- **抓包层 (`capture.py`)**：封装 Scapy `AsyncSniffer`，负责启动、停止、重启和状态查询。
- **解析层 (`packet_parser.py`)**：将原始数据包转换为 `ParsedPacket`，填充网络层、传输层和 DNS 信息。
- **统计层 (`stats.py`)**：维护协议计数器和 IPv6 占比时间序列，为 GUI 图表提供数据。
- **资源监控层 (`resource_monitor.py`)**：后台线程周期性读取 psutil 指标，供 GUI 展示及日志导出。
- **存储层 (`storage.py`)**：实现 JSON 格式的保存与加载，支撑数据持久化和离线分析。

### 4.4 数据流描述
1. 用户点击“开始捕获”，界面将 BPF 过滤条件传递给 `CaptureManager`，由 Scapy 嗅探器接管网络接口。
2. 嗅探到的数据包经 `_safe_callback` 送入 `parse_packet`，解析结果压入 `queue.Queue`。
3. GUI 定时批量取出队列数据，更新数据包列表、详情区和统计模块，同时将资源监控线程采样的 `ResourceSample` 插入资源表。
4. 用户可将 `captured_packets` 序列保存为 JSON；加载文件时重新填充列表并触发统计刷新。

## 5. 主要接口设计与调用关系
- **CaptureManager.start(filter_expr, iface, promisc)**：输入过滤表达式、接口、混杂模式，内部调用 Scapy `AsyncSniffer` 并注册回调；输出为异步回调的原始数据包。
- **PacketCaptureApp._on_packet_captured(packet)**：输入原始包，调用 `parse_packet`，输出 `ParsedPacket` 入队。
- **PacketCaptureApp._drain_packet_queue()**：无输入，由 GUI 计时器触发；批量出队 `ParsedPacket`，更新 `captured_packets`、Treeview 与 `TrafficStats`，并在阈值后刷新图表。
- **parse_packet(packet)**：输入 Scapy 数据包，输出包含网络/传输/DNS 字段的结构化对象。
- **TrafficStats.register(parsed_packet)**：输入解析结果，更新协议计数器与 IPv6 时间序列；供 `_refresh_statistics()` 获取表格与图表数据。
- **ResourceMonitor.start()/stop()**：控制后台线程；回调 `PacketCaptureApp._append_resource_sample` 更新资源表。
- **save_packets/load_packets(path)**：输入文件路径与 `ParsedPacket` 列表，实现 JSON 序列化/反序列化，供 GUI 的保存/加载按钮调用。

调用关系可总结为：GUI 控件触发 → CaptureManager/ResourceMonitor → parse_packet → TrafficStats & GUI 显示 → storage 负责持久化。

## 6. 系统实现
### 6.1 主程序流程（文字版）
Step1：应用启动并初始化界面、抓包管理器、统计模块与资源监控线程。
Step2：用户设置 BPF 过滤条件并点击“开始捕获”，系统启动嗅探器与资源监控。
Step3：嗅探器回调解析数据包，GUI 线程批量拉取解析结果，填充列表与统计视图。
Step4：用户可随时查看详情、切换统计/资源页、保存或加载捕获数据。
Step5：点击“停止”后停止嗅探及资源监控，界面显示运行时长并可导出资源日志。

### 6.2 抓包主循环伪代码
```
while capture_running:
    packet = scapy_sniffer.get()
    parsed = parse_packet(packet)
    enqueue(parsed)
    if queue_length >= batch_threshold:
        drain_queue_and_update_ui()
```

### 6.3 协议解析伪代码
```
function parse_packet(packet):
    info = ParsedPacket()
    if has Ethernet: fill MAC/type
    if IPv4: fill src/dst/ttl/len
    elif IPv6: fill tc/fl/hlim/nh
    elif ARP: fill op/src/dst/hw
    if TCP: fill ports/seq/ack/flags
    elif UDP: fill ports/len
    elif ICMP: fill type/code
    if DNS: fill qr/opcode/qname/counts
    return info
```

### 6.4 运行逻辑说明
- 队列限流：`_drain_packet_queue` 每批最多处理 100 条，并限制 Treeview 仅保留最近 5000 条，提高长时间运行稳定性。
- 统计刷新：通过 `_stats_update_counter` 控制绘图频率，避免频繁重绘；`TrafficStats` 维持 24 小时窗口满足课程要求。
- 资源监控：`ResourceMonitor` 以独立线程读取 psutil，GUI 仅负责呈现和导出，降低 UI 阻塞风险。

## 7. 系统测试
### 7.1 测试用例设计
| 用例 | 测试目的 | 步骤 | 预期结果 | 实际结果 | 截图位置 |
| --- | --- | --- | --- | --- | --- |
| TC01-启动/停止抓包 | 验证 Scapy 嗅探器在 GUI 控制下可启动与停止 | 设置过滤器为空 → 点击“开始捕获”→ 观察列表更新 → 点击“停止” | Treeview 持续出现新条目，停止后不再增长，资源监控停止刷新 | TODO | 此处插入截图：TC01 |
| TC02-过滤表达式 | 验证 BPF 过滤器生效 | 输入 `tcp port 80` → 开始抓包 → 访问 HTTP 服务 | 列表仅显示 TCP/80 报文，协议列包含 TCP | TODO | 此处插入截图：TC02 |
| TC03-数据保存/加载 | 验证 JSON 持久化 | 抓取一定数量数据 → 点击“保存捕获”→ 重启程序 → “加载捕获” | 保存成功并提示文件路径；加载后列表恢复历史数据且统计图刷新 | TODO | 此处插入截图：TC03 |
| TC04-资源日志导出 | 验证资源监控与导出 | 运行程序 ≥5 分钟 → 切到“资源监控”页 → 点击“导出资源日志” | 资源表实时刷新，导出成功生成 JSON 文件 | TODO | 此处插入截图：TC04 |
| TC05-长时间统计 | 验证 IPv6 占比时间线 | 运行 ≥24 小时或加载覆盖全天的数据 → 查看统计页 | IPv6 折线图显示 24 小时曲线，TCP/UDP/ARP 柱状图实时更新 | TODO | 此处插入截图：TC05 |
